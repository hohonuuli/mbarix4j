package mbarix4j3.model.tidal;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.SortedMap;
import java.util.TimeZone;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This class provides an interface to a web accessible tide and current
 * prediction service. It is based on the data generated by the web service
 * located at <a href="http://tbone.biol.sc.edu/tide/">WWW Tide and Current
 * Predictor</a>. This class takes in certain parameters and then constructs a
 * URL to call the tide prediction services to populate tidal information for a
 * certain location over a certain period of time.
 * 
 * This class can be used in a couple of ways. If you know the exact name of the
 * location, you can call it out in the constructor or use the default
 * constructor and then set the location after construction. You will also need
 * to set the start and end times of the window you are interested in. The
 * default time window will be from the current time to 24 hours ahead. So,
 * let's say I know the location as "Monterey Bay, Elkhorn Slough railroad
 * bridge" and I just want the next 24 hours of tide data. I can construct the
 * object like:
 * 
 * <code>
 * TidePredictor tp = new TidePredictor("Monterey Bay, Elkhorn Slough railroad bridge", null, null);
 * </code>
 * 
 * @author kgomes
 * 
 */
public class TidePredictor {
    
	// The currently selected tide location
	private String tideLocation = null;
    
	// This is the URL fragment that is used for the location of choice
	private String tideLocationUrlFragment = null;
    
	// This is the start date and time of the range of tide data available
	private Date startDateTime = null;
    
	// This is the end date and time of the range of tide data available
	private Date endDateTime = null;
    
	// This is the timezone used for the dates and calculations
	private TimeZone timezone = TimeZone.getDefault();
    
	// This is the interval between data points in the request. A happy medium
	// seems to be 30 minutes (for performance reasons), so that is the default
	private int numberOfMinutesBetweenDataPoints = 30;
    
	// This is the URL (string form) of the page to read the tide locations from
	private String tideLocationListUrlString = null;
    
	// This is the base portion of the URL to grab the data
	private String baseUrlTidePredictorString = null;
    
	// The TreeMap containing the actual tide data. The key is the datetime and
	// the value is the tide height
	private TreeMap<Date, Double> tideData = new TreeMap<Date, Double>();
    
	// The maximum tide value found in the currently loaded tideData
	private Double maxTide = Double.MIN_VALUE;
    
	// The minimum tide value found in the currently loaded tideData
	private Double minTide = Double.MAX_VALUE;
    
	// Another map to hold other time/tide related events (full moon, etc.)
	private TreeMap<Date, String> tideEvents = new TreeMap<Date, String>();
    
	// This is a list of the start/end times of the blocks over time that are
	// covered by the data
	private TreeMap<Date, String> coverageMap = new TreeMap<Date, String>();
    
	// This is a boolean to indicate the the instance is currently retrieving
	// data
	private boolean busyRetrievingData = false;

    
	/**
	 * This is the default constructor
	 * 
	 */
	public TidePredictor() {
		// Since this is the default constructor, set the start date to now and
		// the end date to 24 hours from now.
		Calendar aBriefMomentInTime = Calendar.getInstance();
		startDateTime = aBriefMomentInTime.getTime();
		aBriefMomentInTime.add(Calendar.HOUR, 24);
		endDateTime = aBriefMomentInTime.getTime();

		// Try to grab the input stream to read in the properties
		InputStream propStream = getClass().getResourceAsStream(
                                                                "/org/mbari/model/tidal/tidal-predictor.properties");

        
		// Now use it to load in some properties
		Properties tidePredictorProps = new Properties();
		try {
			tidePredictorProps.load(propStream);
		} catch (Throwable t) {
			throw new RuntimeException("Failed to read properties", t);
		}

		// Try to read the tide location list URL from the properties
		this.tideLocationListUrlString = tidePredictorProps
        .getProperty("tideLocationUrlString");
		// Get the base URL for the tide prediction
		this.baseUrlTidePredictorString = tidePredictorProps
        .getProperty("baseUrlTidePredictorString");
	}
    
	/**
	 * 
	 * @param numberOfMinutesBetweenTideDataPoints
	 */
	public TidePredictor(int numberOfMinutesBetweenTideDataPoints) {
		this();
		this.numberOfMinutesBetweenDataPoints = numberOfMinutesBetweenTideDataPoints;
	}
    
	/**
	 * The constructor that takes in a location name, a start date and an end
	 * date. The contructor will go ahead and fetch the data for the specified
	 * location over the specified time.
	 * 
	 * @param locationName
	 * @param startDateTime
	 * @param endDateTime
	 */
	public TidePredictor(String locationName, Date startDateTime,
                         Date endDateTime) throws IllegalArgumentException, IOException {
		// Call the base constructor
		this();
		// Set the tide location name
		this.setTideLocation(locationName);
		// Set the start and end dates
		if ((startDateTime != null) && (endDateTime != null))
			this.setStartAndEndDateTimes(startDateTime, endDateTime);
	}
    
	/**
	 * 
	 * @param locationName
	 * @param startDateTime
	 * @param endDateTime
	 * @param numberOfMinutesBetweenDataPoints
	 * @throws IllegalArgumentException
	 * @throws IOException
	 */
	public TidePredictor(String locationName, Date startDateTime,
                         Date endDateTime, int numberOfMinutesBetweenDataPoints)
    throws IllegalArgumentException, IOException {
		// Call the base constructor
		this();
		// Set the tide location name
		this.setTideLocation(locationName);
		// Set the number of minutes
		this.numberOfMinutesBetweenDataPoints = numberOfMinutesBetweenDataPoints;
		// Set the start and end dates
		if ((startDateTime != null) && (endDateTime != null))
			this.setStartAndEndDateTimes(startDateTime, endDateTime);
	}
    
	/**
	 * This method simply returns the end date of the window over which tide
	 * data will be gathered from the service
	 * 
	 * @return <code>Date</code> that is the end of the data window
	 */
	public Date getEndDateTime() {
		return endDateTime;
	}
    
	/**
	 * This method returns the start date of the window which data will be
	 * gathered from the tide service
	 * 
	 * @return
	 */
	public Date getStartDateTime() {
		return startDateTime;
	}
    
	/**
	 * 
	 * @param startDateTime
	 * @param endDateTime
	 * @throws IllegalArgumentException
	 */
	public void setStartAndEndDateTimes(Date startDateTime, Date endDateTime)
    throws IllegalArgumentException {
		// Check incoming variables
		if ((startDateTime == null) || (endDateTime == null))
			throw new IllegalArgumentException(
                                               "Start and end dates must be specified");
		if (startDateTime.after(endDateTime))
			throw new IllegalArgumentException(
                                               "The specified start date must be "
                                               + "before the specified end date");
        
		// Set the local variables
		this.startDateTime = startDateTime;
		this.endDateTime = endDateTime;
        
		// Now grab any data that might be missing to cover this date range
		this.populateTideData();
	}
    
	/**
	 * This method returns the <code>TimeZone</code> being used for the query
	 * of data
	 * 
	 * @return
	 */
	public TimeZone getTimezone() {
		return timezone;
	}
    
	/**
	 * This method allows the user to set the <code>TimeZone</code> to be used
	 * 
	 * @param timezone
	 */
	public void setTimezone(TimeZone timezone) {
		this.timezone = timezone;
	}
    
	/**
	 * This method simply returns the currently set name of the tide location
	 * 
	 * @return a <code>String</code> that is the &quot;Name&quot; of the
	 *         location where the tide data will be queried from
	 */
	public String getTideLocation() {
		return tideLocation;
	}
    
	/**
	 * This method allows the caller to set the tide location that will be used
	 * for reading tide data. The location specified must match one in the
	 * service's list of locations, or an IllegalArgumentException will be
	 * thrown.
	 * 
	 * @param tideLocation
	 *            a <code>String</code> that is the name of the location to be
	 *            used for gathering tide data.
	 * @throws IllegalArgumentException
	 *             will be thrown if the <code>tideLocation</code> does not
	 *             match one of the tide locations listed at <a
	 *             href="http://tbone.biol.sc.edu/tide/sites_allalpha.html">http://tbone.biol.sc.edu/tide/sites_allalpha.html</a>
	 *             or is <code>null</code>
	 */
	public void setTideLocation(String tideLocation)
    throws IllegalArgumentException, IOException {
        
		// If the location is already set to the location given, do nothing
		if ((this.tideLocation == null)
            || (!this.tideLocation.equals(tideLocation))) {
			// Reset the TidePredictor
			this.resetTidePredictor();
            
			// The first thing to do is find a matching location in the list
			// provided by the service and grab the actual url fragment to be
			// used for data queries
			if ((tideLocation != null) && (!tideLocation.equals(""))) {
                
				// Make sure there is only one matching location found
				HashMap<String, String> locations = getLikeTideLocationsFromService(tideLocation);
				if ((locations == null) || (locations.size() == 0))
					throw new IllegalArgumentException(
                                                       "No matching location was found for '"
                                                       + tideLocation + "'");
				if (locations.size() > 1)
					throw new IllegalArgumentException(
                                                       "More than one location was found "
                                                       + "with that name, please be more specific");
                
				// OK, we should have just one, set the location and URL
				// fragment
				this.tideLocation = locations.keySet().iterator().next();
				this.tideLocationUrlFragment = locations.get(this.tideLocation);
			} else {
				throw new IllegalArgumentException(
                                                   "Incoming tideLocation cannot be null");
			}
		}
	}
    
	/**
	 * This method returns the URL fragment that is used to construct the URL
	 * for the data query
	 * 
	 * @return a <code>String</code> representation of the fragment of the URL
	 *         to find the data
	 */
	public String getTideLocationUrlFragment() {
		return tideLocationUrlFragment;
	}
    
	/**
	 * This method returns the number of Minutes that will be between data
	 * points in the calculated tide prediction. Bigger numbers give better
	 * performance. If you choose very small numbers (1-20 for example) and you
	 * have large time windows, the queries will take a long time.
	 * 
	 * @return <code>int</code> that is the number of minutes between data
	 *         points in the tide data.
	 */
	public int getNumberOfMinutesBetweenDataPoints() {
		return numberOfMinutesBetweenDataPoints;
	}
    
	/**
	 * 
	 * @return
	 */
	public boolean isBusyRetrievingData() {
		return busyRetrievingData;
	}
    
	/**
	 * This method returns the maximum tide that was found in the data.
	 * 
	 * @return a <code>Double</code> that represents the maximum tide found in
	 *         the data. <code>null</code> will be returned if the tide data
	 *         has not been loaded from the service
	 */
	public Double getMaxTide() {
		// If the max was not found, then return null
		if (this.maxTide.equals(Double.MIN_VALUE))
			return null;
		// Return the max
		return maxTide;
	}
    
	/**
	 * This method returns the minimun tide that was found in the data.
	 * 
	 * @return a <code>Double</code> that represents the minimun tide found in
	 *         the data. <code>null</code> is returned if the data has not ben
	 *         loaded from the service
	 */
	public Double getMinTide() {
		// If the min was not found, then return null
		if (this.minTide.equals(Double.MAX_VALUE))
			return null;
		// Return the min
		return minTide;
	}
    
	/**
	 * This method returns the tide data that meets the criterions specified by
	 * the parameters of the class
	 * 
	 * @return
	 */
	public TreeMap<Date, Double> getTideData() {
		// Now return the tidedata
		return tideData;
	}
    
	/**
	 * 
	 * @param startDate
	 * @param endDate
	 * @return
	 * @throws IllegalArgumentException
	 */
	public SortedMap<Date, Double> getTideDataPointsOverDateRange(
                                                                  Date startDate, Date endDate) throws IllegalArgumentException {
        
		// Check to make sure date is available
		if ((startDateTime.after(startDate)) || (endDate.before(endDate))) {
			throw new IllegalArgumentException(
                                               "The sub range you specified is outside "
                                               + "of the range set on the TidePredictor.");
		}
		// Now return sub map
		return tideData.subMap(startDate, endDate);
	}
    
	/**
	 * 
	 * @return
	 */
	public TreeMap<Date, String> getTideEvents() {
		// Now return the tide events
		return tideEvents;
	}
    
	/**
	 * s
	 * 
	 * @param startDate
	 * @param endDate
	 * @return
	 * @throws IllegalArgumentException
	 */
	public SortedMap<Date, String> getTideEventsOverDateRange(Date startDate,
                                                              Date endDate) throws IllegalArgumentException {
		// Check to make sure date is available
		if ((startDateTime.after(startDate)) || (endDate.before(endDate))) {
			throw new IllegalArgumentException(
                                               "The sub range you specified is outside "
                                               + "of the range set on the TidePredictor.");
		}
		// Now return sub map
		return tideEvents.subMap(startDate, endDate);
	}
    
	/**
	 * This method takes in a string and loads all the tide locations available
	 * at the tide prediction service into a hash map locally on the object
	 * 
	 * @param likeString
	 */
	public HashMap<String, String> getLikeTideLocationsFromService(
                                                                   String likeString) {

        
		// The HashMap to return
		HashMap<String, String> tideLocationsAndUrlFragements = new HashMap<String, String>();
        
		// Create the URL to read in the list of locations
		URL tideLocationListUrl = null;
		try {
			tideLocationListUrl = new URL(tideLocationListUrlString);
		} catch (MalformedURLException ex) {
			throw new RuntimeException("Failed to lookup tide location", ex);
		}
		// Open a buffered reader to the URL
		BufferedReader in = null;
		try {
			in = new BufferedReader(new InputStreamReader(tideLocationListUrl
                                                          .openStream()));
		} catch (IOException e) {
			throw new RuntimeException("IOException trying to read location list from URL", e);
		}
        
		// Compile a pattern to be used for finding a matching locations and
		// grabbing its data URL fragment
		Pattern pattern = Pattern
        .compile(".*<a href=\"tideshow.cgi\\?site=(\\S+)\\&units=f\">(.*"
                 + likeString + ".*)</a>.*");
        
		// Read in a line if one is available
		String inputLine = null;
		try {
			while ((inputLine = in.readLine()) != null) {
				// Create the matcher to look for the location string
				Matcher m = pattern.matcher(inputLine);
				if (m.matches()) {
					tideLocationsAndUrlFragements.put(m.group(2), m.group(1));
				}
			}
		} catch (IOException e) {
			throw new RuntimeException("IOException caught reading from the location list URL", e);
		}
        
		// Now return the list
		return tideLocationsAndUrlFragements;
	}
    
	/**
	 * This method simply clears all the settings and starts fresh by nulling
	 * out the tideLocation and all the data, mins, maxs, etc.
	 * 
	 */
	private void resetTidePredictor() {
		this.tideLocation = null;
		this.tideLocationUrlFragment = null;
		this.busyRetrievingData = false;
		this.maxTide = Double.MIN_VALUE;
		this.minTide = Double.MAX_VALUE;
		this.tideData = new TreeMap<Date, Double>();
		this.tideEvents = new TreeMap<Date, String>();
		this.coverageMap = new TreeMap<Date, String>();
	}
    
	/**
	 * This method goes out to the tide predictor service and builds the
	 * <code>TreeMap</code> of tide data that meet the query parameters
	 * 
	 */
	private void populateTideData() {
		// Make sure all the parameters are available
		if ((tideLocation == null) || (tideLocation.equals(""))
            || (startDateTime == null) || (endDateTime == null)
            || (tideLocationUrlFragment == null)
            || (tideLocationUrlFragment.equals(""))) {
			throw new IllegalArgumentException(
                                               "Not all the parameters were set "
                                               + "so tide data could not be retrieved.");
		} else {
			// Now in order to find the time range that will need to be pulled
			// from the tide prediction service, we need to check the currently
			// set start and end times to see if they have already been covered
			if (!this.isDateRangeCovered(startDateTime, endDateTime)) {
				// Set the flag to indicate we are buys
				this.busyRetrievingData = true;
                
				try {
					// Read in the tide data
					HashMap<Date, Double> moreTideData = this
                    .readTideDataFromService();
					// Add it to the current data
					this.addTideDataAndUpdateCoverage(moreTideData);
					// Same for events
					HashMap<Date, String> moreTideEvents = this
                    .readTideEventsFromService();
					this.addTideEvents(moreTideEvents);
				} catch (Throwable t) {
					throw new RuntimeException("Throwable caught trying to read tide data and events from URL", t);
				}
				// Set the flag to indicate we are buys
				this.busyRetrievingData = false;
			}
		}
        
	}
    
	/**
	 * 
	 * @return
	 */
	public boolean isDateRangeCovered(Date startDate, Date endDate) {
		// Create a boolean to track if the date range is covered
		boolean dateRangeCovered = false;
        
		// If the coverage list is not empty, further checks will be needed,
		// otherwise, just return that it is not covered
		if ((this.coverageMap != null) && (this.coverageMap.size() > 0)) {
			// Grab the keys and put in a list
			List<Date> coverageDates = new LinkedList<Date>(coverageMap
                                                            .keySet());
			Collections.sort(coverageDates);
            
			// Grab insertion index for start time
			int startInsertion = Collections.binarySearch(coverageDates,
                                                          startDate);
			// Check to see if it is an exact match
			boolean startIsExactMatch = false;
			if (startInsertion >= 0)
				startIsExactMatch = true;
            
			// Do the same for the end time
			int endInsertion = Collections.binarySearch(coverageDates, endDate);
			boolean endIsExactMatch = false;
			if (endInsertion >= 0)
				endIsExactMatch = true;
            
			// Working with only the start time, there are two cases in which we
			// know it will not be covered. The first is if the index is
			// positive and odd, we know that the start time aligns exactly with
			// an end time and so it will not be covered
			if ((startIsExactMatch) && (startInsertion % 2 == 1))
				return false;
            
			// Second, if the start insertion index is negative and even, that
			// means it is falling before another start time which means the
			// range is not covered
			if ((!startIsExactMatch) && (((startInsertion + 1) * -1) % 2 == 0))
				return false;
            
			// Similarly there are two cases with the end time that will end up
			// with the range not being covered. If the end time is an exact
			// match and it falls on an even index, that means it aligns exactly
			// with a start time and thus the range will not be covered
			if ((endIsExactMatch) && (endInsertion % 2 == 0))
				return false;
            
			// The other end case is when it is not an exact match (so it would
			// be inserted), but the index of insertion would be even which
			// would mean that the end index would be before a start time which
			// means it would not be covered
			if ((!endIsExactMatch) && (((endInsertion + 1) * -1) % 2 == 0))
				return false;
            
			// Other than those cases, it gets a little tricker. There are
			// scenarios for the start time that then depend on the end time. So
			// let's first look at the start time where it is an exact match,
			// and it is even. This means the start time falls directly on
			// another start time and you will need to look at the placement of
			// the end time to figure out if it is covered
			if ((startIsExactMatch) && (startInsertion % 2 == 0)) {
				// The only check we need to make here is if the insertion or
				// exact match index is more than one away. This would mean that
				// the range overlaps several existing ranges and so it would
				// not be covered
				int indexDifference = 0;
				if (endIsExactMatch) {
					indexDifference = endInsertion - startInsertion;
				} else {
					indexDifference = ((endInsertion + 1) * -1)
                    - startInsertion;
				}
				// Now check the difference between the indicies
				if (indexDifference <= 1) {
					// This means it is exactly overlaid on an existing
					// coverage so it would be covered
					return true;
				} else {
					// This means the end index is more than one away which
					// means it crossed gaps between end times and the next
					// start time
					return false;
				}
			}
            
			// The last check to make is if the start time is not an exact
			// match, but the insertion index is odd. This means that the start
			// time does not match exactly, but falls before an end time. That
			// means that coverage is possible, but the time must be equal to or
			// less than the next data in the list
			if ((!startIsExactMatch) && (((startInsertion + 1) * -1) % 2) == 1) {
				//  
				int indexDifference = 0;
				if (endIsExactMatch) {
					indexDifference = endInsertion
                    - ((startInsertion + 1) * -1);
				} else {
					indexDifference = ((endInsertion + 1) * -1)
                    - ((startInsertion + 1) * -1);
				}
				// Now check the difference between the indicies
				if (indexDifference == 0) {
					// This means it is exactly overlaid on an existing
					// coverage so it would be covered
					return true;
				} else {
					// This means the end index is more than one away which
					// means it crossed gaps between end times and the next
					// start time
					return false;
				}
			}
		} else {
			// Set the coverage flag to false
			return false;
		}
        
		return dateRangeCovered;
	}
    
	/**
	 * 
	 * @return
	 */
	private HashMap<Date, Double> readTideDataFromService() {
        
		// Log a message
//		logger
//        .debug("readTideDataFromService called and params are currently :");
//		logger.debug("-> Location = " + tideLocation);
//		logger.debug("-> Location URL Fragment = " + tideLocationUrlFragment);
//		logger.debug("-> Start Date = " + startDateTime);
//		logger.debug("-> End Date = " + endDateTime);
//		logger.debug("-> Number of minutes between points = "
//                     + numberOfMinutesBetweenDataPoints);
        
		// This is the HashMap that will be returned
		HashMap<Date, Double> dataFromServices = new HashMap<Date, Double>();
        
		// Create a Calendar that will hold the start time
		Calendar dateRangeStartCal = Calendar.getInstance();
		dateRangeStartCal.setTime(startDateTime);
        
		// Create a matching Calendar that will hold the end time
		Calendar dateRangeEndCal = Calendar.getInstance();
		dateRangeEndCal.setTime(endDateTime);
        
		// Let's open both ends of the range by a week to make sure we get
		// enough data
		dateRangeStartCal.add(Calendar.MINUTE, -2
                              * numberOfMinutesBetweenDataPoints);
		dateRangeEndCal.add(Calendar.MINUTE,
                            (2 * numberOfMinutesBetweenDataPoints));
//		logger.debug("Opened the query window up to search between "
//                     + dateRangeStartCal.getTime() + " to "
//                     + dateRangeEndCal.getTime());
        
		// Now we need to extract some information from the date range to build
		// the correct URL
		String startYear = dateRangeStartCal.get(Calendar.YEAR) + "";
		String startMonth = (dateRangeStartCal.get(Calendar.MONTH) + 1) + "";
		String startDay = dateRangeStartCal.get(Calendar.DAY_OF_MONTH) + "";
		String startHour = dateRangeStartCal.get(Calendar.HOUR_OF_DAY) + "";
		String startMin = dateRangeStartCal.get(Calendar.MINUTE) + "";
		int numberOfDays = ((dateRangeEndCal.get(Calendar.YEAR) - dateRangeStartCal
                             .get(Calendar.YEAR)) * 365)
        + (dateRangeEndCal.get(Calendar.DAY_OF_YEAR) - (dateRangeStartCal
                                                        .get(Calendar.DAY_OF_YEAR)));
		String glen = numberOfDays + "";
        
		// Now create the URL that will read in the data from the web site
		URL tideDataUrl = null;
		try {
			tideDataUrl = new URL("http://tbone.biol.sc.edu/tide/tideshow.cgi?"
                                  + "tplotdir=horiz;" + "gx=640;" + "gy=240;"
                                  + "caltype=ndp;" + "type=mrare;" + "interval=00%3A30;"
                                  + "glen="
                                  + glen
                                  + ";"
                                  + "fontsize=%2B0;"
                                  + "units=feet;"
                                  + "cleanout=1;"
                                  + "year="
                                  + startYear
                                  + ";"
                                  + "month="
                                  + startMonth
                                  + ";"
                                  + "day="
                                  + startDay
                                  + ";"
                                  + "hour="
                                  + startHour
                                  + ";"
                                  + "min="
                                  + startMin
                                  + ";"
                                  + "tzone=utc;"
                                  + "ampm24=24;"
                                  + "colortext=black;"
                                  + "colordatum=white;"
                                  + "colormsl=yellow;"
                                  + "colortics=red;"
                                  + "colorday=skyblue;"
                                  + "colornight=deep-%3Cbr%20%2F%3Eskyblue;"
                                  + "colorebb=seagreen;"
                                  + "colorflood=blue;"
                                  + "site="
                                  + tideLocationUrlFragment);
//			logger.debug("readTideDataFromService: URL to use: " + tideDataUrl);
		} catch (MalformedURLException ex) {
//			logger
//            .error("MalforedURLException creating the URL to read tide data: "
//                   + ex.getMessage());
		}
		// Open a buffered reader to the URL
		BufferedReader in = null;
		try {
			in = new BufferedReader(new InputStreamReader(tideDataUrl
                                                          .openStream()));
		} catch (IOException e) {
			throw new RuntimeException("IOException caught trying to open buffered reader to URL for tide data", e);
		}
        
		// Compile some patterns to be used for matching and data extraction
		// from the results
		Pattern pattern = Pattern
        .compile("^(\\d{4})-(\\d{2})-(\\d{2})\\s+(\\d{2}):(\\d{2})\\s+(\\S+)\\s+(-*\\d+\\.\\d+)$");
        
		try {
			// The line to be read
			String inputLine = null;
            
			// The variables (Strings) to be extracted
			String year = null;
			String month = null;
			String day = null;
			String hour = null;
			String minute = null;
			String zone = null;
			String dataString = null;
            
			// Loop over all lines read from the URL
			while ((inputLine = in.readLine()) != null) {
				// Check to see if a date can be pulled from the line
				Matcher m = pattern.matcher(inputLine);
				if (m.matches()) {
					// Grab the year
					year = m.group(1);
					// Grab the month
					month = m.group(2);
					// Grab the day
					day = m.group(3);
					// Grab the hour
					hour = m.group(4);
					// Grab the minute
					minute = m.group(5);
					// Grab the timezone
					zone = m.group(6);
					// Grab the data
					dataString = m.group(7);
                    
					// Create a calendar with the parsed information
					Calendar dataPointCalendar = Calendar.getInstance();
                    
					// First grab the old timezone
					String timeZoneID = dataPointCalendar.getTimeZone().getID();
                    
					// This calendar is now in local time, but the stuff read
					// from the URL is in UTC. So, set the timezone to be UTC.
					dataPointCalendar.setTimeZone(TimeZone.getTimeZone("UTC"));
                    
					// Now assign the values to the Calendar that were parsed
					// from the line
					dataPointCalendar
                    .set(Calendar.YEAR, Integer.parseInt(year));
					dataPointCalendar.set(Calendar.MONTH, Integer
                                          .parseInt(month) - 1);
					dataPointCalendar.set(Calendar.DAY_OF_MONTH, Integer
                                          .parseInt(day));
					dataPointCalendar.set(Calendar.HOUR_OF_DAY, Integer
                                          .parseInt(hour));
					dataPointCalendar.set(Calendar.MINUTE, Integer
                                          .parseInt(minute));
                    
					// Since seconds are not returned, zero them out
					dataPointCalendar.set(Calendar.SECOND, 0);
                    
					// I have to call a get method here to make sure the changes
					// in the date actually take. Seems very hackish, but hey,
					// it works
					dataPointCalendar.getTime();
                    
					// Construct the data point
					Double tideDataPoint = null;
					try {
						tideDataPoint =  Double.parseDouble(dataString);
					} catch (NumberFormatException e) {
						throw new RuntimeException("Read tide data point " + dataString
								+ " but could not convert that to a Double", e);

					}
                    
					// Now add this to the local hashmap
					if (tideDataPoint != null) {
						dataFromServices.put(dataPointCalendar.getTime(),
                                             tideDataPoint);
                        
						// Check against mins and max
						if (tideDataPoint.doubleValue() > maxTide.doubleValue())
							maxTide = tideDataPoint;
						if (tideDataPoint.doubleValue() < minTide.doubleValue())
							minTide = tideDataPoint;
					}
				}
			}
		} catch (IOException e) {
			throw new RuntimeException("IOException caught trying to read line from URL", e);
		}
        
		// Print some logger information at finish
//		logger.debug("Done with query and found " + dataFromServices.size()
//                     + " data points in the query results.");
//		logger.debug("After query:");
//		logger.debug("-> Minimum Tide = " + this.minTide);
//		logger.debug("-> Maximum Tide = " + this.maxTide);
        
		// Return the result
		return dataFromServices;
	}
    
	/**
	 * 
	 * @param moreTideData
	 */
	private void addTideDataAndUpdateCoverage(HashMap<Date, Double> moreTideData) {
		// Make sure there is some data to add
		if ((moreTideData != null) && (moreTideData.size() > 0)) {
			// So first, if the data is empty, we need to initialize every thing
			if ((tideData == null) || (tideData.size() <= 0)) {
				// Initialize and add all the data
				tideData = new TreeMap<Date, Double>();
				tideData.putAll(moreTideData);
				coverageMap = new TreeMap<Date, String>();
				coverageMap.put(startDateTime, "START");
				coverageMap.put(endDateTime, "END");
			} else {
				// Data is already existing so we need to add the incoming data
				// and adjust the coverageList appropriately. Adding data is
				// easy. The only criterion is that the insertion index of the
				// date of the data against the coverage list must be negative
				// and even
                
				// Convert the treemap keys (dates) to a list for searching
				List<Date> coverageDates = new LinkedList<Date>(coverageMap
                                                                .keySet());
				Collections.sort(coverageDates);
                
				// So loop over the incoming data
				for (Iterator<Date> dataIterator = moreTideData.keySet()
                     .iterator(); dataIterator.hasNext();) {
					Date dataDate = dataIterator.next();
					if ((Collections.binarySearch(coverageDates, dataDate) < 0)
                        && ((Collections.binarySearch(coverageDates,
                                                      dataDate) + 1) * -1) % 2 == 0) {
						tideData.put(dataDate, moreTideData.get(dataDate));
					}
				}
                
				// Now adjust the coverage list.
				this.updateCoverageMap(startDateTime, endDateTime);
			}
		}
	}
    
	private void updateCoverageMap(Date startDate, Date endDate) {
		// Convert the treemap keys (dates) to a list for searching
		List<Date> coverageDates = new LinkedList<Date>(coverageMap.keySet());
		Collections.sort(coverageDates);
        
		// If one exists, replace the old with the new, otherwise just
		// insert it
		if (Collections.binarySearch(coverageDates, startDate) > 0)
			coverageMap.remove(startDate);
		coverageMap.put(startDate, "START");
		if (Collections.binarySearch(coverageDates, endDate) > 0)
			coverageMap.remove(endDate);
		coverageMap.put(endDate, "END");
        
		// Grab the keys again and re-sort
		coverageDates = new LinkedList<Date>(coverageMap.keySet());
		Collections.sort(coverageDates);
        
		// Remove any entries between the start and end dates
		List<Date> datesBetween = coverageDates.subList(Collections
                                                        .binarySearch(coverageDates, startDate), Collections
                                                        .binarySearch(coverageDates, endDate));
		for (Iterator<Date> dateIter = datesBetween.iterator(); dateIter
             .hasNext();) {
			Date date = dateIter.next();
			if (!date.equals(startDate) && !(date.equals(endDate)))
				coverageMap.remove(date);
		}
        
		// Now I need to run a realignment loop on the until any errors are
		// cleaned up. First declare a boolean that means I made it all the way
		// through the list of dates without hitting an error
		boolean coverageAligned = false;
		while (!coverageAligned) {
			// Grab the list of coverageDates and sort
			List<Date> tempCoverageDates = new LinkedList<Date>(coverageMap
                                                                .keySet());
			Collections.sort(coverageDates);
            
			// Iterate of the dates
			int index = 0;
			int coverageMapSize = tempCoverageDates.size();
			for (Iterator<Date> tempDateIter = tempCoverageDates.iterator(); tempDateIter
                 .hasNext();) {
				Date tempDate = tempDateIter.next();
				// Grab the entry from the coverage map
				String startOrEnd = coverageMap.get(tempDate);
				// If the index is even
				if (index % 2 == 0) {
					if (startOrEnd.equals("END")) {
						coverageMap.remove(tempCoverageDates.get(index - 1));
						break;
					}
				} else {
					if (startOrEnd.equals("START")) {
						coverageMap.remove(tempDate);
						break;
					}
				}
                
				// Bump up the index
				index++;
			}
			// If we are here and index is the same as the size, we know we made
			// it all the way through
			if (index == coverageMapSize)
				coverageAligned = true;
		}
	}
    
	/**
	 * 
	 * @return
	 */
	private HashMap<Date, String> readTideEventsFromService() {
        
		// Log a message
//		logger
//        .debug("readTideEventsFromService called and params are currently :");
//		logger.debug("-> Location = " + tideLocation);
//		logger.debug("-> Location URL Fragment = " + tideLocationUrlFragment);
//		logger.debug("-> Start Date = " + startDateTime);
//		logger.debug("-> End Date = " + endDateTime);
//		logger.debug("-> Number of minutes between points = "
//                     + numberOfMinutesBetweenDataPoints);
        
		// The HashMap of events to be returned
		HashMap<Date, String> eventsReadFromService = new HashMap<Date, String>();
        
		// Create a Calendar that matches the current start time
		Calendar dateRangeStartCal = Calendar.getInstance();
		dateRangeStartCal.setTime(startDateTime);
        
		// Same for the end date
		Calendar dateRangeEndCal = Calendar.getInstance();
		dateRangeEndCal.setTime(endDateTime);
        
		// Let's open both ends of the range by a week to make sure we get
		// enough data
		dateRangeStartCal.add(Calendar.HOUR, (-7 * 24));
		dateRangeEndCal.add(Calendar.HOUR, (7 * 24));
//		logger.debug("Opened the query window up to search between "
//                     + dateRangeStartCal.getTime() + " to "
//                     + dateRangeEndCal.getTime());
        
		// Now we need to extract some information from the event range to
		// build the correct url
		String startYear = dateRangeStartCal.get(Calendar.YEAR) + "";
		String startMonth = (dateRangeStartCal.get(Calendar.MONTH) + 1) + "";
		String startDay = dateRangeStartCal.get(Calendar.DAY_OF_MONTH) + "";
		String startHour = dateRangeStartCal.get(Calendar.HOUR_OF_DAY) + "";
		String startMin = dateRangeStartCal.get(Calendar.MINUTE) + "";
		int numberOfDays = ((dateRangeEndCal.get(Calendar.YEAR) - dateRangeStartCal
                             .get(Calendar.YEAR)) * 365)
        + (dateRangeEndCal.get(Calendar.DAY_OF_YEAR) - (dateRangeStartCal
                                                        .get(Calendar.DAY_OF_YEAR)));
		String glen = numberOfDays + "";
        
		// Now create the URL that will read in the events from the web site
		URL tideEventUrl = null;
		try {
			tideEventUrl = new URL(
                                   "http://tbone.biol.sc.edu/tide/tideshow.cgi?"
                                   + "tplotdir=horiz;" + "gx=640;" + "gy=240;"
                                   + "caltype=ndp;" + "interval=00%3A30;" + "glen="
                                   + glen
                                   + ";"
                                   + "fontsize=%2B0;"
                                   + "units=feet;"
                                   + "cleanout=1;"
                                   + "year="
                                   + startYear
                                   + ";"
                                   + "month="
                                   + startMonth
                                   + ";"
                                   + "day="
                                   + startDay
                                   + ";"
                                   + "hour="
                                   + startHour
                                   + ";"
                                   + "min="
                                   + startMin
                                   + ";"
                                   + "tzone=utc;"
                                   + "ampm24=24;"
                                   + "colortext=black;"
                                   + "colordatum=white;"
                                   + "colormsl=yellow;"
                                   + "colortics=red;"
                                   + "colorday=skyblue;"
                                   + "colornight=deep-%3Cbr%20%2F%3Eskyblue;"
                                   + "colorebb=seagreen;"
                                   + "colorflood=blue;"
                                   + "site=" + tideLocationUrlFragment);
//			logger.debug("readTideEventsFromService: URL to use: "
//                         + tideEventUrl);
		} catch (MalformedURLException ex) {
			throw new RuntimeException("MalforedURLException trying to create URL to read tide events", ex);
		}
        
		// Open a buffered reader to the URL
		BufferedReader in = null;
		try {
			in = new BufferedReader(new InputStreamReader(tideEventUrl
                                                          .openStream()));
		} catch (IOException e) {
			throw new RuntimeException("IOException caught trying to open buffered reader to URL for tide event", e);
		}
        
		// Compile some patterns to be used for matching and data extraction
		Pattern pattern = Pattern
        .compile("^(\\d{4})-(\\d{2})-(\\d{2})\\s+(\\d{2}):(\\d{2})\\s+(\\S+)\\s+"
                 + "(Sunrise|Sunset|Moonrise|Moonset|New Moon|"
                 + "Full Moon|First Quarter|Last Quarter)$");
        
		try {
			// The line to be read from the URL
			String inputLine = null;
            
			// The variable strings to be extracted from the response
			String year = null;
			String month = null;
			String day = null;
			String hour = null;
			String minute = null;
			String zone = null;
			String eventString = null;
            
			// Loop over the lines returned by the query
			while ((inputLine = in.readLine()) != null) {
				// Check to see if a date can be pulled from the line
				Matcher m = pattern.matcher(inputLine);
				if (m.matches()) {
					// Grab the year
					year = m.group(1);
					// Grab the month
					month = m.group(2);
					// Grab the day
					day = m.group(3);
					// Grab the hour
					hour = m.group(4);
					// Grab the minute
					minute = m.group(5);
					// Grab the timezone
					zone = m.group(6);
					// Grab the event string
					eventString = m.group(7);
                    
					// Create a calendar with the parsed information
					Calendar eventCalendar = Calendar.getInstance();
					// First grab the old timezone
					String timeZoneID = eventCalendar.getTimeZone().getID();
                    
					// This calendar is now in local time, but the stuff read
					// from the URL is in UTC. So, set the timezone to be UTC.
					eventCalendar.setTimeZone(TimeZone.getTimeZone("UTC"));
                    
					// Now assign the values
					eventCalendar.set(Calendar.YEAR, Integer.parseInt(year));
					eventCalendar.set(Calendar.MONTH,
                                      Integer.parseInt(month) - 1);
					eventCalendar.set(Calendar.DAY_OF_MONTH, Integer
                                      .parseInt(day));
					eventCalendar.set(Calendar.HOUR_OF_DAY, Integer
                                      .parseInt(hour));
					eventCalendar
                    .set(Calendar.MINUTE, Integer.parseInt(minute));
                    
					// Since seconds are not returned, zero them out
					eventCalendar.set(Calendar.SECOND, 0);
                    
					// I have to call a get method here to make sure the
					// changes in the date actually take. Seems very
					// hackish, but hey, it works
					eventCalendar.getTime();
                    
					// Stuff the results into the hashmap
					eventsReadFromService.put(eventCalendar.getTime(),
                                              eventString);
				}
			}
		} catch (IOException e) {
			throw new RuntimeException("IOException caught trying to read line from URL", e);
		}
        
		// Print some logger information at finish
//		logger.debug("Done with query and found "
//                     + eventsReadFromService.size()
//                     + " events in the query results.");
        
		// Now return the resulting hashmap of events
		return eventsReadFromService;
	}
    
	private void addTideEvents(HashMap<Date, String> moreTideEvents) {
		// Make sure there is some data to add
		if ((moreTideEvents != null) && (moreTideEvents.size() > 0)) {
			// So first, if the events map is empty, we need to initialize every
			// thing
			if ((tideEvents == null) || (tideEvents.size() <= 0)) {
				// Initialize and add all the data
				tideEvents = new TreeMap<Date, String>();
				tideEvents.putAll(moreTideEvents);
			} else {
				// Convert the treemap keys (dates) to a list for searching
				List<Date> coverageDates = new LinkedList<Date>(coverageMap
                                                                .keySet());
				Collections.sort(coverageDates);
                
				// So loop over the incoming data
				for (Iterator<Date> eventDateIterator = moreTideEvents.keySet()
                     .iterator(); eventDateIterator.hasNext();) {
					Date eventDate = eventDateIterator.next();
					if ((Collections.binarySearch(coverageDates, eventDate) < 0)
                        && ((Collections.binarySearch(coverageDates,
                                                      eventDate) + 1) * -1) % 2 == 0) {
						tideEvents
                        .put(eventDate, moreTideEvents.get(eventDate));
					}
				}
			}
		}
        
	}
}
